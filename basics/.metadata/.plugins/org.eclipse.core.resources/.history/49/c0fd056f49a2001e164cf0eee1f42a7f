/*
 * temp_on_lcd.c
 * Displaying the RH and Temperature data from DHT11 Sensor on I2C LCD Module
 * Reference: dht11_sensor_driver.c and lcd_pcf8574_test.c
 *  Created on: 24-Dec-2023
 *      Author: naveen
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "stm32f4xx.h"
#include "gpio_driver.h"
#include "nRFL01_driver.h"
#include "general_purpose_timer.h"
#include "common_utilities.h"

#define DHT11_SENSOR_DATA_PIN			GPIO_PIN_0
#define DHT11_SENSOR_PORT				GPIOA

#define SPI_DEV			SPI2
#define SPI_PORT		GPIOB
#define SPI_PIN_MOSI	15
#define SPI_PIN_MISO	14
#define SPI_PIN_CLK		13
#define SPI_PIN_SS		12							//Not connected. Doing slave select using GPIO (SS_PIN)

#define RADIO_PORT		GPIOA
#define CE_PIN			2
#define IRQ_PIN			0
#define SS_PIN			4

uint8_t check_sensor_response(void);
uint8_t read_dht11_sensor(uint8_t *data);

char tx_buffer[NRF_RADIO_MAX_PKT_LENGTH];
char cmd_buffer[NRF_RADIO_MAX_PKT_LENGTH + 1];
uint8_t tx_packet_length;
uint8_t cmd_packet_length;
uint8_t nrf_packet_tx_state;

int main(void)
{
	uint32_t count = 0;

	//DHT11 Sensor Related Variables
	uint8_t dht11_sensor_response;
	uint8_t dht11_sensor_data[5];

	//NRF24L01 Radio Related Variable
	struct NRF_RADIO_CONFIG_t radio_config;
	uint8_t status;
	uint8_t addr[] = {0xA1,0xA2,0xA3,0xA4,0xA5};      //nRF Radio Link Address

	//Configure the Timer
	configure_delay_timer();

	//Disable printf() buffering
	setbuf(stdout, NULL);

	//Configuring the NRF Radio
	//3. Configure the NRF24L01 Radio
	memset(&radio_config,0,sizeof(radio_config));
	radio_config.radio_mode = NRF_RADIO_MODE_TX;
	radio_config.radio_channel = 10;
	radio_config.radio_data_rate = NRF_RADIO_DATA_RATE_250K;
	radio_config.radio_pa_level = NRF_RADIO_PA_LEVEL_0;
	radio_config.radio_enable_data_pipes = (NRF_RADIO_ERX_P0);
	radio_config.radio_enable_auto_acknowledgements = (NRF_RADIO_ENAA_P0);
	radio_config.radio_address_width = NRF_RADIO_ADDRESS_WIDTH_5B;
	radio_config.radio_auto_retransmit_count = NRF_RADIO_ARC_3;
	radio_config.radio_auto_retransmit_delay = NRF_RADIO_ARD_1000US;
	memcpy(&radio_config.radio_addr_p0, addr, sizeof(addr));
	memcpy(&radio_config.radio_addr_peer, addr, sizeof(addr));
	radio_config.radio_dynamic_payload_length_feature = NRF_RADIO_DPL_FEATURE_ENABLE;
	radio_config.radio_dynamic_payload_enable_pipes = NRF_RADIO_DPL_P0;
	radio_config.radio_ack_payload_feature = NRF_RADIO_ACK_PAYLOAD_FEATURE_DISABLE;
	radio_config.radio_dynamic_ack_feature = NRF_RADIO_DYNAMIC_ACK_FEATURE_ENABLE;

	configure_nrf_radio(&radio_config);

	while(1)
	{
		//Read the DHT11 Sensor
		dht11_sensor_response = read_dht11_sensor(dht11_sensor_data);

		if(dht11_sensor_response)
		{
			printf("DHT11 Sensor Reading Failed\r\n");

			status = nrf_radio_transmit_packet_polling((uint8_t *)tx_buffer,tx_packet_length,NRF_RADIO_ACK);
			if(status == NRF_RADIO_PKT_TX_COMPLETE)
			{
				//Print Message
				printf("Packet %d Transmitted Successfully\r\n",i);
			}
			else if(status == NRF_RADIO_PKT_TX_FAIL)
			{
				//Print Message
				printf("Packet %d Transmission Failed\r\n",i);
			}

		}
		else
		{
			printf("DHT11 Sensor Reading Failed\r\n");
		}

		delay_us(5000000);
	}

	return 0;
}

uint8_t check_sensor_response(void)
{
	uint8_t sample[2];

	//Read First Sample
	delay_us(40);
	sample[0] = GPIOReadPin(DHT11_SENSOR_PORT, DHT11_SENSOR_DATA_PIN);

	//Read Second Sample
	delay_us(80);
	sample[1] = GPIOReadPin(DHT11_SENSOR_PORT, DHT11_SENSOR_DATA_PIN);

	//Wait till the end of the response
	while((GPIOReadPin(DHT11_SENSOR_PORT, DHT11_SENSOR_DATA_PIN)));

	if(sample[0]==GPIO_LOW && sample[1]==GPIO_HIGH)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

uint8_t read_dht11_sensor(uint8_t *data)
{
	uint8_t sensor_response;
	uint8_t current_bit;
	uint8_t i;

	//GPIO Configuration for Sensor Data Pin
	EnablePeriClk(DHT11_SENSOR_PORT);
	GPIOSetMode(DHT11_SENSOR_PORT, DHT11_SENSOR_DATA_PIN, GPIO_MODE_OUTPUT);
	GPIOSetOutputType(DHT11_SENSOR_PORT,DHT11_SENSOR_DATA_PIN,GPIO_OPTYPE_OD);
	GPIOSetOutputSpeed(DHT11_SENSOR_PORT,DHT11_SENSOR_DATA_PIN,GPIO_OPSPEED_HIGH);
	GPIOSetPullUpDownConfig(DHT11_SENSOR_PORT,DHT11_SENSOR_DATA_PIN,GPIO_PULL_UP);

	//Triggering the Sensor
	delay_us(18000);
	GPIOSetMode(DHT11_SENSOR_PORT, DHT11_SENSOR_DATA_PIN, GPIO_MODE_INPUT);

	//Checking for Sensor Response
	sensor_response = check_sensor_response();

	//Reading the Sensor Data
	if(sensor_response == 1)
	{
		for(i=0;i<40;i++)
		{
			while(!(GPIOReadPin(DHT11_SENSOR_PORT, DHT11_SENSOR_DATA_PIN)));
			delay_us(40);
			current_bit = GPIOReadPin(DHT11_SENSOR_PORT, DHT11_SENSOR_DATA_PIN);
			if(current_bit == GPIO_HIGH)
			{
				data[(i/8)] |= (1 << (7-(i%8)));
			}
			else
			{
				data[(i/8)] &= ~(1 << (7-(i%8)));
			}
			while((GPIOReadPin(DHT11_SENSOR_PORT, DHT11_SENSOR_DATA_PIN)));
		}
	}

	return sensor_response;
}
