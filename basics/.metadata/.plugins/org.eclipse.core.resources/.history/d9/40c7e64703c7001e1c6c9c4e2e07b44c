/*
 * task_scheduler.c
 *
 *  Created on: 11-Sep-2023
 *      Author: naveen
 */

#include <stdint.h>
#include <string.h>
#include "stm32f4xx.h"
#include "usart_driver.h"
#include "gpio_driver.h"
#include <stdio.h>
#include "common_utils.h"
#include "os_kernel.h"

#define SLEEP_COUNT			2000

extern uint32_t tick_count;

uint32_t glo_val = 0xFFFF;
Semaphore w;
Semaphore r;

static void producer(void);
static void consumer(void);
static void delay(void);

int main(void)
{
	configure_leds();
	configure_uart();

	os_mutex_init(&m);

	os_create_task(task1,0,1024);
	os_create_task(task2,0,1024);
	os_create_task(task3,0,1024);
	os_create_task(task4,0,1024);
	os_start();

	while(1);

	return 0;
}

static void producer(void)
{
	static uint32_t target_tick_count_1 = TICK_COUNT_TASK_1;

	while(1)
	{
		os_mutex_wait(&m);
		//os_disable_interrupts();
		printf("From Task 1...\r\n");
		//os_enable_interrupts();
		os_mutex_signal(&m);

		//printf("Task 1 Going to Sleep...\r\n");
		//task_sleep(0xFFFFFFFF);
		if(target_tick_count_1 <= tick_count)
		{
			target_tick_count_1 = tick_count + TICK_COUNT_TASK_1;
			GPIOTogglePin(GPIOD, GPIO_PIN_LED_1);
		}

		delay();
	}
}

static void consumer(void)
{
	static uint32_t target_tick_count_2 = TICK_COUNT_TASK_2;

	while(1)
	{
		os_mutex_wait(&m);
		//os_disable_interrupts();
		printf("From Task 2...\r\n");
		//os_enable_interrupts();
		os_mutex_signal(&m);

		//printf("Task 2 Going to Sleep...\r\n");
		//task_sleep(0xFFFFFFFF);
		if(target_tick_count_2 <= tick_count)
		{
			target_tick_count_2 = tick_count + TICK_COUNT_TASK_2;
			GPIOTogglePin(GPIOD, GPIO_PIN_LED_2);
		}

		delay();
	}
}

static void delay(void)
{
	uint32_t j;
	for(j=0;j<SLEEP_COUNT;j++);
}
