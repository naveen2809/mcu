/*
 * nRF24L01_Tx.c
 *
 *  Created on: 18-Dec-2023
 *      Author: naveen
 */


#include <stdint.h>
#include "spi_driver.h"
#include "gpio_driver.h"
#include <string.h>

#define MAX_DATA 500
#define SLEEP_COUNT 10000

#define SPI_DEV			SPI2
#define SPI_PORT		GPIOB
#define SPI_PIN_MOSI	15
#define SPI_PIN_MISO	14
#define SPI_PIN_CLK		13
#define SPI_PIN_SS		12

#define RADIO_PORT		GPIOA
#define PTX_CE			0
#define PTX_IRQ			1

#define TRUE			1
#define FALSE			0

#define NRF_RADIO_MODE_TX				0
#define NRF_RADIO_MODE_RX				1
#define NRF_RADIO_DATA_RATE_250K		0
#define NRF_RADIO_DATA_RATE_1M			1
#define NRF_RADIO_DATA_RATE_2M			2
#define NRF_RADIO_TX_DS_IRQ_ENABLE 		0
#define NRF_RADIO_TX_DS_IRQ_DISABLE 	1
#define NRF_RADIO_RX_DR_IRQ_ENABLE 		0
#define NRF_RADIO_RX_DR_IRQ_DISABLE 	1
#define NRF_RADIO_ACK					0
#define NRF_RADIO_NO_ACK				1
#define NRF_RADIO_PKT_TX_COMPLETE		0
#define NRF_RADIO_PKT_TX_FAIL			1
#define NRF_RADIO_PKT_TX_START			2
#define NRF_RADIO_INT_SRC_TX_DS			0
#define NRF_RADIO_INT_SRC_RX_DR			1
#define NRF_RADIO_INT_SRC_TX_DS			2
#define NRF_RADIO_MAX_PKT_LENGTH		32

struct NRF_RADIO_CONFIG_t
{
	uint8_t radio_mode;
	uint8_t radio_channel;
	uint8_t radio_data_rate;
	uint8_t	radio_auto_acknowledgement;
};

void delay(void)
{
	uint32_t j;
	for(j=0;j<SLEEP_COUNT;j++);
}

void configure_spi(void);
void configure_nrf_radio(void);
void nrf_radio_transmit_packet(uint8_t *buffer,uint8_t length,uint8_t ack_policy);
void nrf_radio_receive_packet_callback(uint8_t *buffer, uint8_t length);

char tx_buffer[NRF_RADIO_MAX_PKT_LENGTH];
uint8_t tx_packet_length;
uint8_t nrf_packet_tx_state;

int main(void)
{
	uint8_t status;

	tx_buffer = "Hello World\r\n";
	tx_packet_length = strlen(tx_buffer);

	//1. Configure the SPI Port connecting to NRF24L01 Radio
	configure_spi();

	//2. Configure the NRF24L01 Radio


	configure_nrf_radio();


	//3. Transmit a Packet
	status = nrf_radio_transmit_packet((uint8_t *)tx_buffer,tx_packet_length,NRF_RADIO_ACK);
	if(status == NRF_RADIO_PKT_TX_COMPLETE)
	{
		//Print Message
	}
	else if(status == NRF_RADIO_PKT_TX_FAIL)
	{
		//Print Message
	}


	while(1);

	return 0;

}

void configure_spi(void)
{
	struct SPI_Config_t SPI_Dev_Config;

	//Configuring the GPIO Pins for the SPI Port
	EnablePeriClk(SPI_PORT);
	GPIOSetMode(SPI_PORT,SPI_PIN_MOSI,GPIO_MODE_ALTFN);
	GPIOSetMode(SPI_PORT,SPI_PIN_MISO,GPIO_MODE_ALTFN);
	GPIOSetMode(SPI_PORT,SPI_PIN_CLK,GPIO_MODE_ALTFN);
	GPIOSetMode(SPI_PORT,SPI_PIN_SS,GPIO_MODE_ALTFN);
	GPIOSetAltFn(SPI_PORT,SPI_PIN_MOSI,GPIO_ALTFN_5);
	GPIOSetAltFn(SPI_PORT,SPI_PIN_MISO,GPIO_ALTFN_5);
	GPIOSetAltFn(SPI_PORT,SPI_PIN_CLK,GPIO_ALTFN_5);
	GPIOSetAltFn(SPI_PORT,SPI_PIN_SS,GPIO_ALTFN_5);

	//Configuring the SPI Peripheral
	SPI_Dev_Config.SPIDeviceMode = SPI_DEVICE_MODE_MASTER;
	SPI_Dev_Config.SPIClockPol = SPI_CLK_POL_0;
	SPI_Dev_Config.SPIClockPhase = SPI_CLK_PHA_LE;
	SPI_Dev_Config.SPIClockFreq = SPI_CLK_FREQ_DIV4;
	SPI_Dev_Config.SPIDataFrameFormat = SPI_DFF_8_BITS;
	SPI_Dev_Config.SPISoftwareSlaveManagement = SPI_SW_SLAVE_MGNT_DI;
	SPI_Dev_Config.SPISSIFlag = SPI_SSI_1;
	SPI_Dev_Config.SPISSOEFlag = SPI_SSOE_EN;

	EnablePeriClk(SPI_DEV);
	SPIPeriConfig(SPI_DEV, &SPI_Dev_Config);
	SPIEnable(SPI_DEV);
}

void configure_nrf_radio(void)
{

}

uint8_t nrf_radio_transmit_packet(uint8_t *buffer,uint8_t length,uint8_t ack_policy)
{

	nrf_packet_tx_state = NRF_RADIO_PKT_TX_START;

	//1. Send packet to radio using SPI interface

	//2. Pulse the PTX CE line for more than 10us
	GPIOWritePin(RADIO_PORT,PTX_CE,GPIO_HIGH);
	delay_us(10);
	GPIOWritePin(RADIO_PORT,PTX_CE,GPIO_LOW);

	//3. Wait for confirmation of packet transmission from NRF24L01 radio
	while(nrf_packet_tx_state == NRF_RADIO_PKT_TX_START);              //Packet TX state is updated in the ISR

	return nrf_packet_tx_state;
}

void nrf_radio_receive_packet_callback(uint8_t *buffer, uint8_t length)
{
	//Print message
	printf("Packet Received from Peer Radio\r\n");

	//Print packet length
	printf("Packet Length: %d\r\n",length);

	//Print packet contents
	printf("Packet Contents: %s\r\n",(char *)buffer);

	return;
}

void nrf_radio_interrupt_callback(void)
{
	uint8_t interrupt_source;

	//1. Identify interrupt source
	interrupt_source = get_interrupt_source();

	//2.

	return;
}
