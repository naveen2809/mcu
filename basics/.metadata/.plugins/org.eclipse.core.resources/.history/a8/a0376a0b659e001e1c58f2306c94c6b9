/*
 * nRF24L01_Tx.c
 *
 *  Created on: 18-Dec-2023
 *      Author: naveen
 */

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "spi_driver.h"
#include "gpio_driver.h"
#include "usart_driver.h"
#include "common_utilities.h"
#include "external_interrupt_config.h"

#define SPI_DEV			SPI2
#define SPI_PORT		GPIOB
#define SPI_PIN_MOSI	15
#define SPI_PIN_MISO	14
#define SPI_PIN_CLK		13
#define SPI_PIN_SS		12

#define RADIO_PORT		GPIOA
#define CE_PIN			2
#define IRQ_PIN			0

#define UART_GPIO_PORT		GPIOD
#define UART_TX_PIN			GPIO_PIN_5
#define UART_RX_PIN			GPIO_PIN_6

#define NRF_RADIO_MODE_TX				0
#define NRF_RADIO_MODE_RX				1
#define NRF_RADIO_DATA_RATE_250K		0
#define NRF_RADIO_DATA_RATE_1M			1
#define NRF_RADIO_DATA_RATE_2M			2
#define NRF_RADIO_TX_DS_IRQ_ENABLE 		0
#define NRF_RADIO_TX_DS_IRQ_DISABLE 	1
#define NRF_RADIO_RX_DR_IRQ_ENABLE 		0
#define NRF_RADIO_RX_DR_IRQ_DISABLE 	1
#define NRF_RADIO_ACK					0
#define NRF_RADIO_NO_ACK				1
#define NRF_RADIO_PKT_TX_COMPLETE		0
#define NRF_RADIO_PKT_TX_FAIL			1
#define NRF_RADIO_PKT_TX_START			2
#define NRF_RADIO_INT_SRC_TX_DS			0
#define NRF_RADIO_INT_SRC_RX_DR			1
#define NRF_RADIO_INT_SRC_MAX_RT		2
#define NRF_RADIO_PA_LEVEL_0			0
#define NRF_RADIO_PA_LEVEL_1			1
#define NRF_RADIO_PA_LEVEL_2			2
#define NRF_RADIO_PA_LEVEL_3			3
#define NRF_RADIO_MAX_PKT_LENGTH		32

#define NRF_RADIO_CMD_R_REGISTER_CONFIG				0x00
#define NRF_RADIO_CMD_R_REGISTER_EN_AA				0x01
#define NRF_RADIO_CMD_R_REGISTER_EN_RXADDR			0x02
#define NRF_RADIO_CMD_R_REGISTER_SETUP_AW			0x03
#define NRF_RADIO_CMD_R_REGISTER_SETUP_RETR			0x04
#define NRF_RADIO_CMD_R_REGISTER_RF_CH				0x05
#define NRF_RADIO_CMD_R_REGISTER_RF_SETUP			0x06
#define NRF_RADIO_CMD_R_REGISTER_STATUS				0x07
#define NRF_RADIO_CMD_R_REGISTER_OBSERVE_TX			0x08
#define NRF_RADIO_CMD_R_REGISTER_RPD				0x09
#define NRF_RADIO_CMD_R_REGISTER_RX_ADDR_P0			0x0A
#define NRF_RADIO_CMD_R_REGISTER_RX_ADDR_P1			0x0B
#define NRF_RADIO_CMD_R_REGISTER_RX_ADDR_P2			0x0C
#define NRF_RADIO_CMD_R_REGISTER_RX_ADDR_P3			0x0D
#define NRF_RADIO_CMD_R_REGISTER_RX_ADDR_P4			0x0E
#define NRF_RADIO_CMD_R_REGISTER_RX_ADDR_P5			0x0F
#define NRF_RADIO_CMD_R_REGISTER_TX_ADDR			0x10
#define NRF_RADIO_CMD_R_REGISTER_RX_PW_P0			0x11
#define NRF_RADIO_CMD_R_REGISTER_RX_PW_P1			0x12
#define NRF_RADIO_CMD_R_REGISTER_RX_PW_P2			0x13
#define NRF_RADIO_CMD_R_REGISTER_RX_PW_P3			0x14
#define NRF_RADIO_CMD_R_REGISTER_RX_PW_P4			0x15
#define NRF_RADIO_CMD_R_REGISTER_RX_PW_P5			0x16
#define NRF_RADIO_CMD_R_REGISTER_FIFO_STATUS
#define NRF_RADIO_CMD_R_REGISTER_ACK_PLD
#define NRF_RADIO_CMD_R_REGISTER_TX_PLD
#define NRF_RADIO_CMD_R_REGISTER_RX_PLD
#define NRF_RADIO_CMD_R_REGISTER_DYNPD
#define NRF_RADIO_CMD_R_REGISTER_FEATURE

#define NRF_RADIO_CMD_W_REGISTER_CONFIG				0x20
#define NRF_RADIO_CMD_W_REGISTER_EN_AA				0x21
#define NRF_RADIO_CMD_W_REGISTER_EN_RXADDR			0x22
#define NRF_RADIO_CMD_W_REGISTER_SETUP_AW			0x23
#define NRF_RADIO_CMD_W_REGISTER_SETUP_RETR			0x24
#define NRF_RADIO_CMD_W_REGISTER_RF_CH				0x25
#define NRF_RADIO_CMD_W_REGISTER_RF_SETUP			0x26
#define NRF_RADIO_CMD_W_REGISTER_STATUS				0x27
#define NRF_RADIO_CMD_W_REGISTER_OBSERVE_TX			0x28
#define NRF_RADIO_CMD_W_REGISTER_RPD				0x29
#define NRF_RADIO_CMD_W_REGISTER_RX_ADDR_P0			0x2A
#define NRF_RADIO_CMD_W_REGISTER_RX_ADDR_P1			0x2B
#define NRF_RADIO_CMD_W_REGISTER_RX_ADDR_P2			0x2C
#define NRF_RADIO_CMD_W_REGISTER_RX_ADDR_P3			0x2D
#define NRF_RADIO_CMD_W_REGISTER_RX_ADDR_P4			0x2E
#define NRF_RADIO_CMD_W_REGISTER_RX_ADDR_P5			0x2F
#define NRF_RADIO_CMD_W_REGISTER_TX_ADDR			0x30
#define NRF_RADIO_CMD_W_REGISTER_RX_PW_P0
#define NRF_RADIO_CMD_W_REGISTER_RX_PW_P1
#define NRF_RADIO_CMD_W_REGISTER_RX_PW_P2
#define NRF_RADIO_CMD_W_REGISTER_RX_PW_P3
#define NRF_RADIO_CMD_W_REGISTER_RX_PW_P4
#define NRF_RADIO_CMD_W_REGISTER_RX_PW_P5
#define NRF_RADIO_CMD_W_REGISTER_FIFO_STATUS
#define NRF_RADIO_CMD_W_REGISTER_ACK_PLD
#define NRF_RADIO_CMD_W_REGISTER_TX_PLD
#define NRF_RADIO_CMD_W_REGISTER_RX_PLD
#define NRF_RADIO_CMD_W_REGISTER_DYNPD
#define NRF_RADIO_CMD_W_REGISTER_FEATURE

#define NRF_RADIO_CMD_R_RX_PAYLOAD			0x61
#define NRF_RADIO_CMD_W_TX_PAYLOAD			0xA0
#define NRF_RADIO_CMD_FLUSH_TX				0xE1
#define NRF_RADIO_CMD_FLUSH_RX				0xE2
#define NRF_RADIO_CMD_REUSE_TX_PL			0xE3
#define NRF_RADIO_CMD_R_RX_PL_WID			0x60
#define NRF_RADIO_CMD_W_ACK_PAYLOAD_PIPE0	0xA8
#define NRF_RADIO_CMD_W_ACK_PAYLOAD_PIPE1	0xA9
#define NRF_RADIO_CMD_W_ACK_PAYLOAD_PIPE2	0xAA
#define NRF_RADIO_CMD_W_ACK_PAYLOAD_PIPE3	0xAB
#define NRF_RADIO_CMD_W_ACK_PAYLOAD_PIPE4	0xAC
#define NRF_RADIO_CMD_W_ACK_PAYLOAD_PIPE5	0xAD
#define NRF_RADIO_CMD_W_TX_PAYLOAD_NOACK	0xB0
#define NRF_RADIO_CMD_NOP					0xFF

struct NRF_RADIO_CONFIG_t
{
	uint8_t radio_mode;
	uint8_t radio_channel;
	uint8_t radio_data_rate;
	uint8_t radio_pa_level;
	uint8_t	radio_auto_acknowledgement;
};

void configure_nrf_radio(struct NRF_RADIO_CONFIG_t * radio_config);
uint8_t nrf_radio_transmit_packet(uint8_t *buffer,uint8_t length,uint8_t ack_policy);
void nrf_radio_receive_packet_callback(uint8_t *buffer, uint8_t length);
uint8_t nrf_radio_get_interrupt_source(void);
void nrf_radio_send_packet_to_fifo(uint8_t *buffer,uint8_t length,uint8_t ack_policy);
void nrf_radio_retreive_packet_from_fifo(void);

void configure_spi(void);
void configure_radio_interrupts(void);
void configure_uart(void);
void UART_SendChar(uint8_t ch);

char tx_buffer[NRF_RADIO_MAX_PKT_LENGTH] = "Hello World\r\n";
char rx_buffer[NRF_RADIO_MAX_PKT_LENGTH];
uint8_t tx_packet_length;
uint8_t rx_packet_length;
uint8_t nrf_packet_tx_state;

struct USART_Handle_t Test_USART;

int main(void)
{
	struct NRF_RADIO_CONFIG_t radio_config;
	uint8_t status;

	tx_packet_length = strlen(tx_buffer);

	//1.a Configure the Timer Peripheral
	configure_delay_timer();

	//1.b Configure the UART Peripheral
	configure_uart();

	//1.c Configure Radio Interrupts
	configure_radio_interrupts();

	//2. Configure the SPI Port connecting to NRF24L01 Radio
	configure_spi();

	//3. Configure the NRF24L01 Radio
	memset(&radio_config,0,sizeof(radio_config));
	radio_config.radio_mode = NRF_RADIO_MODE_TX;
	radio_config.radio_channel = 1;
	radio_config.radio_data_rate = NRF_RADIO_DATA_RATE_250K;
	radio_config.radio_pa_level = NRF_RADIO_PA_LEVEL_0;

	configure_nrf_radio(&radio_config);

	//4. Transmit a Packet
	status = nrf_radio_transmit_packet((uint8_t *)tx_buffer,tx_packet_length,NRF_RADIO_ACK);
	if(status == NRF_RADIO_PKT_TX_COMPLETE)
	{
		//Print Message
		printf("Packet Transmitted Successfully\r\n");
	}
	else if(status == NRF_RADIO_PKT_TX_FAIL)
	{
		//Print Message
		printf("Packet Transmission Failed\r\n");
	}

	while(1);

	return 0;

}

void configure_spi(void)
{
	struct SPI_Config_t SPI_Dev_Config;

	//Configuring the GPIO Pins for the SPI Port
	EnablePeriClk(SPI_PORT);
	GPIOSetMode(SPI_PORT,SPI_PIN_MOSI,GPIO_MODE_ALTFN);
	GPIOSetMode(SPI_PORT,SPI_PIN_MISO,GPIO_MODE_ALTFN);
	GPIOSetMode(SPI_PORT,SPI_PIN_CLK,GPIO_MODE_ALTFN);
	GPIOSetMode(SPI_PORT,SPI_PIN_SS,GPIO_MODE_ALTFN);
	GPIOSetAltFn(SPI_PORT,SPI_PIN_MOSI,GPIO_ALTFN_5);
	GPIOSetAltFn(SPI_PORT,SPI_PIN_MISO,GPIO_ALTFN_5);
	GPIOSetAltFn(SPI_PORT,SPI_PIN_CLK,GPIO_ALTFN_5);
	GPIOSetAltFn(SPI_PORT,SPI_PIN_SS,GPIO_ALTFN_5);

	//Configuring the SPI Peripheral
	SPI_Dev_Config.SPIDeviceMode = SPI_DEVICE_MODE_MASTER;
	SPI_Dev_Config.SPIClockPol = SPI_CLK_POL_0;
	SPI_Dev_Config.SPIClockPhase = SPI_CLK_PHA_LE;
	SPI_Dev_Config.SPIClockFreq = SPI_CLK_FREQ_DIV4;
	SPI_Dev_Config.SPIDataFrameFormat = SPI_DFF_8_BITS;
	SPI_Dev_Config.SPISoftwareSlaveManagement = SPI_SW_SLAVE_MGNT_DI;
	SPI_Dev_Config.SPISSIFlag = SPI_SSI_1;
	SPI_Dev_Config.SPISSOEFlag = SPI_SSOE_EN;

	EnablePeriClk(SPI_DEV);
	SPIPeriConfig(SPI_DEV, &SPI_Dev_Config);
	SPIEnable(SPI_DEV);
}

void configure_nrf_radio(struct NRF_RADIO_CONFIG_t * radio_config)
{
	//1. Configure the GPIO pins for CE and IRQ pins
	EnablePeriClk(RADIO_PORT);
	GPIOSetMode(RADIO_PORT,CE_PIN,GPIO_MODE_OUTPUT);
	GPIOWritePin(RADIO_PORT,CE_PIN,GPIO_LOW);
	GPIOSetMode(RADIO_PORT,IRQ_PIN,GPIO_MODE_INPUT);
	GPIOSetPullUpDownConfig(RADIO_PORT,IRQ_PIN,GPIO_PULL_UP);

	//2. Configure the Radio Mode

	//3. Configure the RF Channel, Data Rate and PA Level

	//4. Configure Own Address

	//5. Configure Peer Address

	//6. Configure Enhanced Short Burst Mode Features
	//(Auto-acknowledgement, Retry Limit, Dynamic Packet Length, Interrupts etc.)


	return;
}

uint8_t nrf_radio_transmit_packet(uint8_t *buffer,uint8_t length,uint8_t ack_policy)
{

	nrf_packet_tx_state = NRF_RADIO_PKT_TX_START;

	//1. Send packet to radio using SPI interface
	nrf_radio_send_packet_to_fifo(buffer,length,ack_policy);

	//2. Pulse the PTX CE line for more than 10us
	GPIOWritePin(RADIO_PORT,CE_PIN,GPIO_HIGH);
	delay_us(10);
	GPIOWritePin(RADIO_PORT,CE_PIN,GPIO_LOW);

	//3. Wait for confirmation of packet transmission from NRF24L01 radio
	while(nrf_packet_tx_state == NRF_RADIO_PKT_TX_START);              //Packet TX state is updated in the ISR

	return nrf_packet_tx_state;
}

void nrf_radio_receive_packet_callback(uint8_t *buffer, uint8_t length)
{
	//Print message
	printf("Packet Received from Peer Radio\r\n");

	//Print packet length
	printf("Packet Length: %d\r\n",length);

	//Print packet contents
	printf("Packet Contents: %s\r\n",(char *)buffer);

	return;
}

void nrf_radio_interrupt_callback(void)
{
	uint8_t interrupt_source;

	//1. Identify interrupt source
	interrupt_source = nrf_radio_get_interrupt_source();

	//2. Handle the interrupt source
	if(interrupt_source == NRF_RADIO_INT_SRC_RX_DR)
	{
		nrf_radio_retreive_packet_from_fifo();
		nrf_radio_receive_packet_callback((uint8_t *)rx_buffer,rx_packet_length);
	}
	else if(interrupt_source == NRF_RADIO_INT_SRC_TX_DS)
	{
		nrf_packet_tx_state = NRF_RADIO_PKT_TX_COMPLETE;
	}
	else if(interrupt_source == NRF_RADIO_INT_SRC_MAX_RT)
	{
		nrf_packet_tx_state = NRF_RADIO_PKT_TX_FAIL;
	}

	return;
}

uint8_t nrf_radio_get_interrupt_source(void)
{
	uint8_t interrupt_source;

	return interrupt_source;
}

void nrf_radio_retreive_packet_from_fifo(void)
{

}

void nrf_radio_send_packet_to_fifo(uint8_t *buffer,uint8_t length,uint8_t ack_policy)
{

}

void configure_uart(void)
{
	//GPIO Pin Configuration
	EnablePeriClk(UART_GPIO_PORT);
	GPIOSetMode(UART_GPIO_PORT,UART_TX_PIN,GPIO_MODE_ALTFN);
	GPIOSetMode(UART_GPIO_PORT,UART_RX_PIN,GPIO_MODE_ALTFN);
	GPIOSetAltFn(UART_GPIO_PORT,UART_TX_PIN,GPIO_ALTFN_7);
	GPIOSetAltFn(UART_GPIO_PORT,UART_RX_PIN,GPIO_ALTFN_7);
	GPIOSetOutputType(UART_GPIO_PORT,UART_TX_PIN,GPIO_OPTYPE_PP);
	GPIOSetOutputType(UART_GPIO_PORT,UART_RX_PIN,GPIO_OPTYPE_PP);
	GPIOSetOutputSpeed(UART_GPIO_PORT,UART_TX_PIN,GPIO_OPSPEED_HIGH);
	GPIOSetOutputSpeed(UART_GPIO_PORT,UART_RX_PIN,GPIO_OPSPEED_HIGH);
	GPIOSetPullUpDownConfig(UART_GPIO_PORT,UART_TX_PIN,GPIO_PULL_UP);
	GPIOSetPullUpDownConfig(UART_GPIO_PORT,UART_RX_PIN,GPIO_PULL_UP);

	//USART Configuration
	Test_USART.pUSART = (struct USART_RegDef_t *) USART2;
	Test_USART.USART_Config.USART_Mode = USART_MODE_TX_RX;
	Test_USART.USART_Config.USART_DataLength = USART_DATA_LEN_8_BITS;
	Test_USART.USART_Config.USART_StopBits = USART_STOP_BITS_1;
	Test_USART.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
	Test_USART.USART_Config.USART_BaudRate = USART_SB_RATE_9600;
	Test_USART.USART_Config.USART_HWFlowControl = USART_HW_FLOW_CNTRL_NONE;

	EnablePeriClk(USART2);
	USART_Init(&Test_USART);
	USART_PeripheralEnable(&Test_USART);
}

void UART_SendChar(uint8_t ch)
{
	USART_SendData(&Test_USART, &ch, 1);
}

void configure_radio_interrupts(void)
{
	configure_external_interrupt();
}

void EXTI0_IRQHandler(void)
{
	uint32_t *pEXTI_PR = (uint32_t *) EXTI_PR_ADDR;

	//1. Handling the interrupt
	nrf_radio_interrupt_callback();

	//2. Clearing the EXTI_PR Register
	*pEXTI_PR |= (1 << INTERRUPT_PIN);

	return;
}
